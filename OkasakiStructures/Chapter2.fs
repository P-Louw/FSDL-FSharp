namespace Okasaki.C2Persistence
open System.Collections.Immutable;

// This disables the warning generated by the match used in 'CustomStack.update',
// nothing can fall through the final when clause but the compiler doesn't see this.
#nowarn "25"

/// Figure 2.1 Example of a 'Stack' signature but with list
/// nomenclature. For a more usable example see:
/// http://www.fssnip.net/er/title/Implementation-of-Immutable-Stack
type LStack<'a> = {
    stack: ImmutableStack<'a>
    empty: ImmutableStack<'a>
    isEmpty: ImmutableStack<'a> -> bool
    cons: 'a * ImmutableStack<'a> -> ImmutableStack<'a>
    head: ImmutableStack<'a> -> 'a
    tail: ImmutableStack<'a> -> 'a
}

/// Figure 2.2 List stack implemented using F# built-in list type
/// instead of user defined stack signature.
[<RequireQualifiedAccess>]
module ListStack =
   type ListStack<'a> =
       'a list
       
   let Empty: ListStack<_> = []
   
   let isEmpty listStack =
       List.isEmpty listStack
       
   let cons x (xs:ListStack<_>): ListStack<_> = 
       x::xs
   
   let head s = List.head s
   
   let tail s = List.tail s
   
/// Figure 2.3 Custom stack with DU 'Empty' for NIL value.
[<RequireQualifiedAccess>]
module CustomStack =
    type CStack<'a> =
        | Empty
        | Cons of 'a * CStack<'a>
        
    /// Operators placed in a nested module w/o required qualified access for usability.
    module Operators =
        /// Append a CStack list to a existing one in a imperative way.
        /// This 'destroys' the previous list because of mutating the previous representation.
        let rec (++) x xs =
            match x with
            | Empty -> xs
            | Cons(h, t) -> Cons(h, t ++ xs)

    let empty = Empty
    
    let isEmpty = function
        | Empty -> true
        | _ -> false
        
    let cons x xs = Cons(x, xs)
    
    let head = function
        | Empty -> failwith "empty"
        | Cons(x, _) -> x
        
    let tail = function
        | Empty -> failwith "empty"
        | Cons(_, xs) -> xs
        
        
    /// Figure 2.4 Append a CStack list to a existing one in a declarative way,
    /// preserving the previous representation by copying from the affected node. 
    let rec update = function
        | (Empty, _, _) -> failwith "subscript is invalid"
        | (Cons(_, xs), 0, x) -> Cons(x, xs)
        | (Cons(_, xs), i, x) when i > 0 -> update (xs, i - 1, x)

/// Examples of user defined stack/list structures.
module Examples =
    open CustomStack.Operators

    // Create a empty Cons node
    let emptyConsNode: CustomStack.CStack<double> = CustomStack.empty
    // Create a Cons node
    let consNode = CustomStack.cons 137 CustomStack.Empty
    
    let nestStack = CustomStack.cons 42 consNode 

    let merged = (CustomStack.cons 32 CustomStack.empty) ++ nestStack

    let iStackHead = CustomStack.head merged
    let iStackTail = CustomStack.tail merged

    let isItEmpty = CustomStack.isEmpty merged

    
